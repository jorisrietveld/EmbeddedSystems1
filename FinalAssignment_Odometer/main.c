/**
 * Author: Joris Rietveld <jorisrietveld@gmail.com>
 * Created: 19-10-2017 16:28
 * License: GPLv3 - General Public License version 3
 */

// Defines for  easy bit flipping
#define    bit_set(...)        bit_set_(__VA_ARGS__)
#define    bit_set_(x,y)        x |= 1<<y            // set a bit
#define    bit_clear(...)        bit_clear_(__VA_ARGS__)
#define    bit_clear_(x,y)        x &= ~(1<<y)            // clear a bit
#define    bit_test(...)        bit_test_(__VA_ARGS__)
#define    bit_test_(x,y)        (!!(x & (1<<y)))        // test a bit
#define    bit_test_in(...)    bit_test_in_(__VA_ARGS__)
#define    bit_test_in_(x,y)    (!!(*(&x-2) & (1<<y)))        // access PINx of PORTx !

#define IMPERIAL_SYSTEM 1
#define METRIC_SYSTEM 1

#define SEGMENT_OUTPUT PORTC
#define DISPLAY_OUTPUT PORTA

volatile uint64_t odoMeterPulseCount = 0; // The amount of pulses generated by the odometer.
volatile uint64_t rmsMeterStartValue = 0; // The amount of pulses fetched from the odometerPulseCounter when the sample started.
volatile uint64_t dayMeterStartValue = 0; // The amount of pulses fetched from the odometerPulseCounter when the sample started.
volatile uint64_t drivingSpeedStartValue = 0; // The amount of pulses fetched from the odometerPulseCounter when the sample started.

volatile uint32_t currentOdoMeterDistance = 0; // The current distance the car has traveled since its fabrication. (in kilometers/miles depending on the localization settings)
volatile uint16_t currentResolutionsPerMinute = 0; // The current amount resolutions of the car engine.
volatile uint32_t currentDayMeterDistance = 0; // The current distance the car has traveled since the last day meter reset. ( in kilometers/miles per hour depending on the localization settings)
volatile uint16_t currentDrivingSpeed = 0; // The current driving speed of the car. ( in kilometers/miles per hour depending on the localization settings)

uint8_t characterEncodings[10][7] = {
        { 0xDF, 0xBF, 0xFB, 0xF7, 0xEF, 0xFE, 0xFF },  // Sequence of encoded segments to create the number 0
        { 0xBF, 0xFB, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },  // Sequence of encoded segments to create the number 1
        { 0xDF, 0xBF, 0xFD, 0xEF, 0xF7, 0xFF, 0xFF },  // Sequence of encoded segments to create the number 2
        { 0xDF, 0xBF, 0xFD, 0xFB, 0xF7, 0xFF, 0xFF },  // Sequence of encoded segments to create the number 3
        { 0xFE, 0xFD, 0xBF, 0xFB, 0xFF, 0xFF, 0xFF },  // Sequence of encoded segments to create the number 4
        { 0xDF, 0xFE, 0xFD, 0xFB, 0xF7, 0xFF, 0xFF },  // Sequence of encoded segments to create the number 5
        { 0xDF, 0xFB, 0xF7, 0xEF, 0xFE, 0xFD, 0xFF },  // Sequence of encoded segments to create the number 6
        { 0xDF, 0xBF, 0xFB, 0xFF, 0xFF, 0xFF, 0xFF },  // Sequence of encoded segments to create the number 7
        { 0xDF, 0xBF, 0xFB, 0xF7, 0xEF, 0xFE, 0xFD },  // Sequence of encoded segments to create the number 8
        { 0xDF, 0xBF, 0xFB, 0xF7, 0xFE, 0xFD, 0xFF },  // Sequence of encoded segments to create the number 9
};

ISR(TIMER0_OVF_vect)
{
    DISPLAY_OUTPUT ~(1<<)
    PORT_PWR &= ~(1 << (i_active_display+4));    // turn off LED
    //toggle active display
    i_active_display ^= 1;

    if(i_active_display == 0) {
        seven_write(i_timer_seconds % 10);
    } else {
        seven_write(i_timer_seconds / 10 % 10);
    }

    PORT_PWR |= (1 << (i_active_display+4));    // turn on LED
}

// todo routine to update display
/**
 * The display multiplex routine
 * fetch the next byte of the encoded segment buffer
 * write the next byte to the segment ports
 * increment the segment index array.
 */

// Todo routine to update pulse counter
/**
 * The external interrupt routine.
 * increment the pulse counter.
 */

// Todo routing to sample measurement
/**
 * The sampler routine is responsible for updating the the display preparation buffer.
 * calculate the current driving speed
 * calculate the current Odometer value
 * calculate the current Day meter value
 * calculate the current Tachometer value
 */


// Todo initiating the I/O ports on the device

// Todo writing the main routine of the device

void initRegisters();
void updateWriteBuffer();

void main()
{
    intitRegistetrs();
}

void initRegisters()
{
    // todo init IO directions
    // Todo init timers

    TCNT0 = 0; // Initiate the Timer/Counter register of timer 0  with an value of 0;
    //TCCR0 |= (1 << CS00); // Set Timer/Counter control register to: Select Source from Internal and no prescaling
    TCCR0 |= (1 << CS01); // Set Timer/Counter control register to: Select Source from Internal and prescale 8
    // 255


    // Todo init interrupts
}

void updateWriteBuffer()
{

}
